<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <title>Chapter3: Logback configuration</title>
    
    <link rel="stylesheet" type="text/css" href="../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen" />

  </head>
  <body onload="prettyPrint()">

    <script type="text/javascript">prefix='../'</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <div id="left">
      <noscript>Please turn on Javascript to view this menu</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content" class="chapter">
      
      <h1>Chapter 3: Logback configuration</h1>
      
    <div class="quote">
      <p><em>In symbols one observes an advantage in discovery which
      is greatest when they express the exact nature of a thing
      briefly and, as it were, picture it; then indeed the labor of
      thought is wonderfully diminished.</em>
      </p>
      <p>&mdash;GOTTFRIED WILHELM LEIBNIZ</p>
    </div>


    <script src="../templates/creative.js" type="text/javascript"></script>


    <p>Joran stands for a cold north-west wind which, every now and
    then, blows forcefully on Lake Geneva. Located right in the middle
    of Europe, the Geneva lake happens to be the continent's largest
    sweet water reserve.
    </p>

    <p>In the first part, we start by presenting ways for configuring
    logback, with many example configuration scripts.  In the <a
    href="#Joran">second part</a>, we present Joran, a generic
    configuration framework, which you can put into use in order to
    configure your own applications.
    </p>


    <h2>    
      <a name="auto_configuration" href="#auto_configuration">
        Configuration in logback
      </a>
    </h2>
    
    <p>Inserting log requests into the application code requires a
    fair amount of planning and effort. Observation shows that
    approximately four percent of code is dedicated to
    logging. Consequently, even a moderately sized application will
    contain thousands of logging statements embedded within its
    code. Given their number, we need tools to manage these log
    statements.
    </p>

    <p>Logback can be configured either programmatically or with a
    configuration script (expressed in XML format). By the way,
    existing log4j users can convert their <em>log4j.properties</em>
    files to <em>logback.xml</em> using our <a
    href="http://logback.qos.ch/translator/">PropertiesTranslator</a>
    web-application.
    </p>

    <p>Let us begin by discussing the initialization steps that
    logback follows to try to configure itself:
    </p>

    <ol>
      <li>
        <p>Logback tries to find a file called
        <em>logback-test.xml</em> <a
        href="../faq.html#configFileLocation">in the
        classpath</a>.</p>
      </li>

      <li><p>If no such file is found, it checks for the file
      <em>logback.xml</em>  <a
        href="../faq.html#configFileLocation">in the
        classpath</a>..</p>
      </li>
      
      <li><p>In case neither file is found, logback configures itself
      automatically using the <a
      href="../xref/ch/qos/logback/classic/BasicConfigurator.html"><code>BasicConfigurator</code></a>
      which will cause logging output to be directed on the console.
      </p> 
      </li> 

    </ol>

    <p>The third and last step is meant to provide a default (but very
    basic) logging functionality in the absence of a configuration
    file.
    </p>


    <p>If you are using Maven and assuming the
    <em>logback-test.xml</em> file is placed under
    <em>src/test/resources</em> folder, Maven will ensure that it
    won't be included in the artifact produced. Thus, you can use a
    different configuration file, namely <em>logback-test.xml</em>
    during testing, and another file, namely, <em>logback.xml</em>, in
    production. The same principle applies by analogy for Ant.
    </p>


    <h3>Automatically configuring logback</h3>

    <p>The simplest way to configure logback is by letting logback
    fall back to its default configuration. Let us give a taste of how
    this is done in an imaginary application called
    <code>MyApp1</code>.
    </p>

    <em>Example 3.<span class="autoEx"/>: Simple example of
    <code>BasicConfigurator</code> usage <a
    href="../xref/chapter3/MyApp1.html">(logback-examples/src/main/java/chapter3/MyApp1.java)</a></em>

    <pre class="prettyprint source">package chapter3;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyApp1 {
  final static Logger logger = LoggerFactory.getLogger(MyApp1.class);

  public static void main(String[] args) {
    logger.info("Entering application.");

    Foo foo = new Foo();
    foo.doIt();
    logger.info("Exiting application.");
  }
}</pre>

  <p>This class defines a static logger variable. It then
  instantiates a Foo object. The Foo class is listed below:
  </p>

  <em>Example 3.<span class="autoEx"/>: Small class doing logging 
  <a href="../xref/chapter3/Foo.html">(logback-examples/src/main/java/chapter3/Foo.java)</a>
  </em>

  <pre class="prettyprint source">package chapter3;
  
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
   
public class Foo {
  static final Logger logger = LoggerFactory.getLogger(Foo.class);
  
  public void doIt() {
    logger.debug("Did it again!");
  }
}</pre>


    <p>In order to run the examples in this chapter, you need to make
    sure that certain jar files are present on the class path.  Please
    refer to the <a href="../setup.html">setup page</a> for further
    details.
    </p>

  

    <p>Assuming the configuration files <em>logback-test.xml</em> or
    <em>logback.xml</em> are not present, logback will default to
    invoking <a
    href="../xref/ch/qos/logback/classic/BasicConfigurator.html"><code>BasicConfigurator</code></a>
    which will set up a minimal configuration. This minimal
    configuration consists of a <code>ConsoleAppender</code> attached
    to the root logger.  The output is formatted using a
    <code>PatternLayout</code> set to the pattern <em>%d{HH:mm:ss.SSS}
    [%thread] %-5level %logger{36} - %msg%n</em>. Moreover, by default
    the root logger is assigned the <code>DEBUG</code> level.
    </p>

    <p>Thus, the output of the command <em>java chapter3.MyApp1</em>
    should be similar to:
    </p>

    <p class="source">16:06:09.031 [main] INFO  chapter3.MyApp1 - Entering application.
16:06:09.046 [main] DEBUG chapter3.Foo - Did it again!
16:06:09.046 [main] INFO  chapter3.MyApp1 - Exiting application.</p>


   <div class="highlight">
      <p>
        Except code that configures logback (if such code exists)
        client code does not need to depend on logback. Applications
        that use logback as their logging framework will have a
        compile-time dependency on SLF4J but not logback.
      </p>
    </div>   

   <p>The <code>MyApp1</code> application links to logback via calls
   <code>org.slf4j.LoggerFactory</code> and
   <code>org.slf4j.Logger</code> classes, retrieve the loggers it
   wishes to use, and chugs on.  Note that the only dependencies of
   the <code>Foo</code> class on logback are through
   <code>org.slf4j.LoggerFactory</code> and
   <code>org.slf4j.Logger</code> imports.  Except code that configures
   logback (if such code exists) client code does not need to depend
   on logback. Given that SLF4J permits the use of any logging
   framework under its abstraction layer, it is rather easy to migrate
   large bodies of code from one logging framework to another.
   </p>

   <h3>Automatic configuration with <em>logback-test.xml</em> or
   <em>logback.xml</em></h3>

   <p>As mentioned earlier, logback will try to configure itself using
   the files <em>logback-test.xml</em> or <em>logback.xml</em> if
   found on the class path. Here is a configuration file equivalent to
   the one established by <code>BasicConfigurator</code> we've just
   seen.
   </p>

 <p><em>Example 3.<span class="autoEx"/>: Basic configuration file
  (logback-examples/src/main/java/chapter3/sample0.xml)</em></p>


<pre class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

   <p>After you have renamed <em>sample0.xml</em> as
   <em>logback.xml</em> (or <em>logback-test.xml</em>) place it into a
   directory accessible from the class path. Running the <em>MyApp1</em>
   application should give identical results to its previous run.</p>

   <h4>Automatic printing of status messages in case of warning or errors</h4>

   <div class="highlight">
     <p>If warning or errors occur during the parsing of the
     configuration file, logback will automatically print its internal
     status messages on the console.
     </p>
   </div>

   <p>If warnings or errors occur during the parsing of the
   configuration file, logback will automatically print status data on
   the console. In the absence of warnings or errors, if you still
   wish to inspect logback's internal status, then you can instruct
   logback to print status data by invoking the <code>print()</code>
   of the <code>StatusPrinter</code> class. The <em>MyApp2</em>
   application shown below is identical to <em>MyApp1</em> except the
   addition of two lines of code for printing internal status
   data.</p>

    <em>Example 3.<span class="autoEx"/>: Print logback's internal status information
    <a
    href="../xref/chapter3/MyApp2.html">(logback-examples/src/main/java/chapter3/MyApp2.java)</a></em>

  
<pre class="prettyprint lang-java source">
  public static void main(String[] args) {
    // assume SLF4J is bound to logback in the current environment
    <b>LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
    // print logback's internal status
    <b>StatusPrinter.print(lc);</b>
    ...
  }</pre>

  <p>If everything goes well, you should see the following output on the console</p>

   <div class="source longline"><pre>17:44:58,578 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback-test.xml]
17:44:58,671 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - debug attribute not set
17:44:58,671 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.ConsoleAppender]
17:44:58,687 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [STDOUT]
17:44:58,812 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Popping appender named [STDOUT] from the object stack
17:44:58,812 |-INFO in ch.qos.logback.classic.joran.action.LevelAction - root level set to DEBUG
17:44:58,812 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [STDOUT] to Logger[root]

17:44:58.828 [main] INFO  chapter3.MyApp2 - Entering application.
17:44:58.828 [main] DEBUG chapter3.Foo - Did it again!
17:44:58.828 [main] INFO  chapter3.MyApp2 - Exiting application.
</pre></div>

  <p>At the end of this output, you can recognize the lines that were
  printed in the previous example. You should also notice the
  logback's internal messages, a.k.a. <code>Status</code> objects,
  which allow convenient access to logback's internal state.
  </p>

   <p>Instead of invoking <code>StatusPrinter</code> programmatically
   from your code, you can instruct the configuration file to dump
   status data, even in the absence of errors. To achieve this, you
   need to set the <span class="attr">debug</span> attribute of the
   <em>configuration</em> element, i.e. the top-most element in the
   configuration file, as shown below. Please note that this <span
   class="attr">debug</span> attribute relates only to the status
   data. It does <em>not</em> affect logback's configuration
   otherwise, in particular with respect to logger levels. (If you are
   asking, no, the root logger will <em>not</em> be set to
   <code>DEBUG</code>.)
   </p>


   <em>Example 3.<span class="autoEx"/>: Basic configuration file
   using debug mode
   (logback-examples/src/main/java/chapter3/sample1.xml)</em>

<pre class="prettyprint source">
&lt;configuration <b>debug="true"</b>> 

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"> 
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>
  
   <p>Setting the <code>debug</code> attribute within the
   &lt;configuration&gt; element will output status information, under
   the assumption that
   </p>
   <ol>
     <li>the configuration file is found</li>
     <li>the configuration file is well-formed XML.</li>
   </ol>
     
   <p>If any of these two conditions is not fulfilled, Joran cannot
   interpret <code>debug</code> attribute since the configuration file
   cannot be read. If the configuration file is found but is
   ill-formed, then logback will detect the error condition and
   automatically print its internal status on the console. However, if
   the configuration file cannot be found, since this is not
   necessarily an error condition, logback will not automatically
   print its status data.  Programmatically invoking
   <code>StatusPrinter.print()</code>, as as in <em>MyApp2</em>
   application above, ensures that status information is always
   printed.
   </p>

   <h3>Specifying the location of the default configuration file as a
   system property</h3>

   <p>If you wish, you can specify the location of the default
   configuration file with a system property named
   <code>logback.configurationFile</code>. The value of the this
   property can be a URL, a resource on the class path or a path to a
   file external to the application.
   </p>

   <p class="source">java <b>-Dlogback.configurationFile=/path/to/config.xml</b> chapter3.MyApp1</p>


   <h3><a name="autoScan" href="#autoScan">Automatically reloading
   configuration file upon modification</a></h3>

   <div class="highlight">
     <p>Logback-classic can scan for changes in its configuration file
     and automatically reconfigure itself when the said configuration
     file changes.
     </p>
   </div>

   <p>If instructed to do so, logback-classic will scan for changes in
   its configuration file and automatically reconfigure itself when
   the said configuration file changes. In order to instruct
   logback-classic to scan for changes in its configuration file and
   to automatically re-configure itself set the <span
   class="attr">scan</span> atrribute of the
   <code>&lt;configuration></code> element to true, as shown next.

   </p>
  <em>Example 3.<span class="autoEx"/>: Scanning for changes in
  configuration file and automatic re-configuraion
  (logback-examples/src/main/java/chapter3/scan1.xml)</em>

<pre class="prettyprint source">
&lt;configuration <b>scan="true"</b>> 
  ...
&lt;/configuration> </pre>


   <p>By default, the configuration file will be scanned for changes
   once every minute. You can specify a different scanning period by
   setting the <span class="attr">scanPeriod</span> attribute of the
   <code>&lt;configuration></code> element. Values can be specified in
   units of milliseconds, seconds, minutes or hours. Here is an
   example:</p>

  <em>Example 3.<span class="autoEx"/>: Specifying a different
  scanning period
  (logback-examples/src/main/java/chapter3/scan2.xml)</em>

<pre class="prettyprint source">
&lt;configuration scan="true" <b>scanPeriod="30 seconds"</b> > 
  ...
&lt;/configuration> </pre>

   <p>If no unit of time is specified, then the unit of time is
   assumed to be milliseconds, which is usually inappropriate. If you
   change the default scanning period, do not forget to specify a time
   unit.
   </p>

   <p>Behind the scenes, when you set the scan attribute to true, a
   <code>TurboFilter</code> called <a
   href="../xref/ch/qos/logback/classic/turbo/ReconfigureOnChangeFilter.html">ReconfigureOnChangeFilter</a>
   will be installed. TurboFilters are described in a <a
   href="filters.html#TurboFilter">later chapter</a>. As a
   consequence, scanning is done "in-thread", that is anytime a
   printing method of logger is invoked. For example, for a logger
   named <code>myLogger</code>, when you write
   "myLogger.debug("hello");", and if the scan attribute is set to
   true, then <code>ReconfigureOnChangeFilter</code> will be
   invoked. Moreover, the said filter will be invoked even if
   <code>myLogger</code> is disabled for the debug level.
   </p>

   <p>Given that <code>ReconfigureOnChangeFilter</code> is invoked
   every time <em>any</em> logger is invoked, the filter is
   performance critical. In order to improve performance, instead of
   checking whether to scan or not on every logger invocation,
   <code>ReconfigureOnChangeFilter</code> is in reality "alive" only
   once every 16 logging operations. In short, when a configuration
   file changes, it will be automatically reloaded after a delay
   determined by the scanning period and several logger invocations.
   </p>

   

   <h3>Invoking <code>JoranConfigurator</code> directly</h3>

   <p>Logback relies on a configuration library called Joran which is
   part of logback-core. Logback's default configuration mechanism
   invokes <code>JoranConfigurator</code> on the default configuration
   file it finds on the class path. For whatever reason if you wish to
   override logback's default configuration mechanism, you can do so
   by invoking <code>JoranConfigurator</code> directly. The next
   application, <em>MyApp3</em>, invokes JoranConfigurator on a
   configuration file passed as a parameter.</p>
   
   <p><em>Example 3.<span class="autoEx"/>: Invoking
   <code>JoranConfigurator</code> directly <a
   href="../xref/chapter3/MyApp3.html">(logback-examples/src/main/java/chapter3/MyApp3.java)</a></em></p>

<pre class="prettyprint source">package chapter3;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class MyApp3 {
  final static Logger logger = LoggerFactory.getLogger(MyApp3.class);

  public static void main(String[] args) {
    // assume SLF4J is bound to logback in the current environment
    <b>LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
    
    <b>try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(lc);
      // the context was probably already configured by default configuration 
      // rules
      lc.reset(); 
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
       je.printStackTrace();
    }
    StatusPrinter.printInCaseOfErrorsOrWarnings(lc);</b>

    logger.info("Entering application.");

    Foo foo = new Foo();
    foo.doIt();
    logger.info("Exiting application.");
  }
}</pre>

   <p>This application fetches the <code>LoggerContext</code>
   currently in effect, creates a new <code>JoranConfigurator</code>,
   sets the context on which it will operate, resets the logger
   context, and then finally asks the configurator to configure the
   context using configuration file passed as parameter to the
   application. Internal status data is printed in case of warnings or
   errors.
   </p>   

   <h3><a name="viewingStatusMessages"
   href="#viewingStatusMessages">Viewing status messages</a>
   </h3>



   <p>Logback collects its internal status data in a <code><a
   href="../xref/ch/qos/logback/core/status/StatusManager.html">StatusManager</a></code>
   object, accessible via the <code>LoggerContext</code>.
   </p>

   <p>Given a <code>StatusManager</code> you an access all the status
   data associated with a logback context. To keep memory usage at
   reasonable levels, the default <code>StatusManager</code>
   implementation stores the status messages in two separate parts:
   the header part and the tail part. The header part stores the fist
   <em>H</em> status messages whereas the tail part stores the last
   <em>T</em> messages. At present time <em>H</em>=<em>T</em>=150,
   although these values may change in future releases.</p>

   <p>Logback-classic ships with a servlet called
   ViewStatusMessagesServlet. This servlet prints the contents of the
   <code>StatusManager</code> associated with the current
   <code>LoggerContext</code> as an HTML table. Here is sample output.
   </p>
   
   <a href="images/chapter3/lbClassicStatus.jpg">
     <img src="images/chapter3/lbClassicStatus.jpg" alt="click to enlarge" width="90%"/>
   </a>

   <p>To add this servlet to your web-application, add the following
   lines to its <em>WEB-INF/web.xml</em> file.</p>

   <pre class="prettyprint source">  &lt;servlet>
    &lt;servlet-name>ViewStatusMessages&lt;/servlet-name>
    &lt;servlet-class>ch.qos.logback.classic.ViewStatusMessagesServlet&lt;/servlet-class>
  &lt;/servlet>

  &lt;servlet-mapping>
    &lt;servlet-name>ViewStatusMessages&lt;/servlet-name>
    &lt;url-pattern>/lbClassicStatus&lt;/url-pattern>
  &lt;/servlet-mapping></pre>
   
   <p>The <code>ViewStatusMessages</code> servlet will viewable under
   the URL <code>http://host/yourWebapp/lbClassicStatus</code>
   </p>

   <h3>
     <a name="statusListener" href="#statusListener">Listening to
     status messages</a>
   </h3>



   <p>You may also attach a <code>StatusListener</code> to a
   <code>StatusManager</code> so that you can take immediate action in
   response to status messages, especially to messages occurring after
   logback configuration. Registering a status listener is a
   convenient way to supervise logback's internal state without human
   intervention.
   </p>

   <p>Logback ships with a <code>StatusListener</code> implementation
   called <code><a
   href="../xref/ch/qos/logback/core/status/OnConsoleStatusListener.html">OnConsoleStatusListener</a></code>
   which, as its name indicates, prints all <em>new</em> incoming
   status messages on the console.
   </p>

   <p>Here is <a
   href="../xref/chapter3/AddStatusListenerApp.html">sample code</a>
   to register an OnConsoleStatusListener instance with the
   StatusManager.
   </p>

   <pre class="prettyprint source">   LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory(); 
   StatusManager statusManager = lc.getStatusManager();
   OnConsoleStatusListener onConsoleListener = new OnConsoleStatusListener();
   statusManager.add(onConsoleListener);</pre>

   <p>Note that the registered status listener will receive status
   events subsequent to its registration. It will not receive prior
   messages.</p>

   <p>It is also possible to register one or more status listeners
   within a configuration file. Here is an example.</p>

  <p><em>Example 3.<span class="autoEx"/>: Registering a status listener (logback-examples/src/main/java/chapter3/onConsoleStatusListener.xml)</em></p>

   <pre class="prettyprint source">&lt;configuration>
  <b>&lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /></b>  

  ... the rest of the configuration file  
&lt;/configuration></pre>

   <p>One may also register a status listener by setting the
   "logback.statusListenerClass" Java system property to the name of
   the listener class you wish to register. For example,
   </p>

   <p class="source">java <b>-Dlogback.statusListenerClass</b>=ch.qos.logback.core.status.OnConsoleStatusListener&nbsp;...</p>
   



   <h2>
     <a name="syntax" href="#syntax">Configuration file Syntax</a>
   </h2>

	<p>To obtain these different logging behaviors we do not need to
	recompile code.  You can easily configure logback so as to disable
	logging for certain parts of your application, or direct output to a
	UNIX Syslog daemon, to a database, to a log visualizer, or forward
	logging events to a remote logback server, which would log according
	to local server policy, for example by forwarding the log event to a
	second logback server.
  </p>
	
  <p>The remainder of this section presents the syntax of
  configuration files. 
  </p>

  <p>As shall become clear, the syntax of logback configuration files
  is extremely flexible. As such, it is not possible to specify the
  allowed syntax with a DTD file or an XML schema. Nevertheless, the
  very basic structure of the configuration file can be described as,
  &lt;configuration> element, followed by zero or more &lt;appender>
  elements, followed by zero or more &lt;logger> elements, followed by
  at most one &lt;root> element. The following diagram illustrates
  this basic structure.</p>

  
  <p align="left">
    <img src="images/chapter3/basicSyntax.png" 
         alt="basic Syntax" title="Basic configuration file structure"/>
  </p>


  <div class="highlight">
    <p>If you are unsure which case to use for a given tag name, just
    follow the camelCase convention which should usually be
    corrrect.</p>
  </div>

  <p>As of logback version 0.9.17, tag names pertaining to explicit
  rules are case insensitive.  For example, both
  <code>&lt;logger></code>, <code>&lt;Logger></code> and
  <code>&lt;LOGGER></code> are valid configuration elements and will
  be interpreted in the same way. Note that XML well-formedness rules
  still apply, if you open a tag as <code>&lt;xyz></code> you must
  close it as <code>&lt;/xyz></code>, <code>&lt;/XyZ></code> will not
  work. As for <a href="onJoran.html#implicit">implicit rules</a>, tag
  names are case sensitive except for the first letter.  Thus,
  <code>&lt;xyz></code> and <code>&lt;Xyz></code> are equivalent but
  not <code>&lt;xYz></code>.  Implicit rules usually follow the <a
  href="http://en.wikipedia.org/wiki/CamelCase">camel case</a>
  convention, common in the Java world. Since it is not trivially easy
  tell when a tag is associated with an explicit action and when it is
  associated with an implicit action, it is not trivial to say whether
  an XML tag is totally case-insensitive or case-insensitive with
  respect to the first letter. If you are unsure which case to use for
  a given tag name, just follow the camelCase convention which should
  usually be correct.
  </p>

  <h4>Configuring Loggers, or the <code>&lt;logger></code> element</h4>

  <p>A logger is configured using the <code>logger</code> element. A
  <em>logger</em> element takes exactly one mandatory <span
  class="attr">name</span> attribute, an optional <span
  class="attr">level</span> attribute, and an optional <span
  class="attr">additivity</span> attribute, which admits the values
  <em>true</em> or <em>false</em>. The value of the <span
  class="attr">level</span> attribute can be one of the
  case-insensitive strings TRACE, DEBUG, INFO, WARN, ERROR, ALL or
  OFF. The special case-insensitive value <em>INHERITED</em>, or its
  synonym <em>NULL</em>, will force the level of the logger to be
  inherited from higher up in the hierarchy. This comes in handy in
  case you set the level of a logger and later decide that it should
  inherit its level.
  </p>

  <p>The <em>logger</em> element may contain zero or more
  <em>appender-ref</em> elements; each appender thus referenced is
  added to the named logger. It is important to keep mind that each
  named logger that is declared with a &lt;logger element first has
  all its appenders removed and only then are the referenced appenders
  attached to it.  In particular, if there are no appender references,
  then the named logger will lose all its appenders.
  </p>



  <h4>Configuring the root logger, or the <code>&lt;root></code>
  element</h4>



  <p>The &lt;root> element configures the root logger. It admits a
  single attribute, namely the <span class="attr">level</span>
  attribute. It does not admit any other attributes because the
  additivity flag does not apply to the root logger.  Moreover, since
  the root logger is already named as "ROOT", it does not admit a name
  attribute either. The value of the level attribute can be set to one
  of the case-insensitive strings TRACE, DEBUG, INFO, WARN, ERROR, ALL
  or OFF. Note that the level of the root logger cannot be set to
  INHERITED or NULL.
  </p>


  <p>The &lt;root> element admits zero or more &lt;appender-ref>
  elements.  Similar to the &lt;logger element, declaring a &lt;root
  element will have the effect of first closing and then detaching all
  its current appenders and only subsequently will referenced
  appenders, if any, will be added.  In particular, if it has no
  appender references, then the root logger will lose all its
  appenders.
  </p>

  <h4>Example</h4>

  <p>Setting the level of a logger or root logger is as simple as
  declaring it and setting its level, as the next example
  illustrates. Suppose we are no longer interested in seeing any DEBUG
  messages from any component belonging to the "chapter3" package. The
  following configuration file shows how to achieve that.
  </p>

<em>Example 3.<span class="autoEx"/>: Setting the level of a logger (logback-examples/src/main/java/chapter3/sample2.xml)</em>
<pre class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  <b>&lt;logger name="chapter3" level="INFO"/></b>

  &lt;!-- Strictly speaking, the level attribute is not necessary since --&gt;
  &lt;!-- the level of the root level is set to DEBUG by default.       --&gt;
  &lt;root level="DEBUG">		
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>  
  
&lt;/configuration></pre>

  <p>This new configuration will yield the following output, when
  invoked with the <em>MyApp3</em> application.
  </p>

<pre class="source">17:34:07.578 [main] INFO  chapter3.MyApp3 - Entering application.
17:34:07.578 [main] INFO  chapter3.MyApp3 - Exiting application.</pre>

  <p>You can configure the levels of as many loggers as you wish.  In
  the next configuration file, we set the level of the
  <em>chapter3</em> logger to INFO but at the same time set the level
  of the <em>chapter3.Foo</em> logger to <code>DEBUG</code>.
  </p>

<em>Example 3.<span class="autoEx"/>: Setting the level of multiple loggers (logback-examples/src/main/java/chapter3/sample3.xml)</em>
<pre class="source prettyprint">&lt;configuration>

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
     &lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  <b>&lt;logger name="chapter3" level="INFO" />
  &lt;logger name="chapter3.Foo" level="DEBUG" /></b>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>

&lt;/configuration></pre>

  <p>Running <code>MyApp3</code> with this configuration file will
  result in the following output on the console:
  </p>

<p class="prettyprint source">17:39:27.593 [main] INFO  chapter3.MyApp3 - Entering application.
17:39:27.593 [main] DEBUG chapter3.Foo - Did it again!
17:39:27.593 [main] INFO  chapter3.MyApp3 - Exiting application.</p>

   <p>The table below list the loggers and their levels, after
   <code>JoranConfigurator</code> has configured logback with the
   <em>sample3.xml</em> configuration file.
   </p>

   <table class="bodyTable">
     <tr>
       <th>Logger name</th>
       <th>Assigned Level</th>
       <th>Effective Level</th>
     </tr>
     <tr>
       <td>root</td>
       <td><code>DEBUG</code></td>
       <td><code>DEBUG</code></td>
     </tr>
     <tr class="alt">
       <td>chapter3</td>
       <td><code>INFO</code></td>
       <td><code>INFO</code></td>
     </tr>
     <tr>
       <td>chapter3.MyApp3</td>
       <td><code>null</code></td>
       <td><code>INFO</code></td>
     </tr>
     <tr class="alt">
       <td>chapter3.Foo</td>
       <td><code>DEBUG</code></td>
       <td><code>DEBUG</code></td>
     </tr>
   </table>

  <p>It follows that the two logging statements of level
  <code>INFO</code> in the <code>MyApp3</code> class as well as the
  DEBUG messages in <code>Foo.doIt()</code> are all enabled. Note that
  the level of the root logger is always set to a non-null value,
  which is DEBUG by default.  
  </p>

  <p>Let us note that the <a
  href="architecture.html#basic_selection">basic-selection rule</a>
  depends on the effective level of the logger being invoked, not the
  level of the logger where appenders are attached. Loback will first
  determine wheteher a logging statement is enabled or not, and if
  enabled, it will invoke the appenders found in the logger hierarchy,
  regardless of their level. The configuration file
  <em>sample4.xml</em> is a case in point:
  </p>

  <em>Example 3.<span class="autoEx"/>: Logger level sample
  (logback-examples/src/main/java/chapter3/sample4.xml)</em>
<pre class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT"
   class="ch.qos.logback.core.ConsoleAppender">
   &lt;layout class="ch.qos.logback.classic.PatternLayout">
     &lt;Pattern>
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
      &lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  <b>&lt;logger name="chapter3" level="INFO" /></b>

  &lt;!-- turn OFF all logging (children can override) -->
  &lt;root <b>level="OFF"</b>>
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>

&lt;/configuration></pre>

  <p>The following table lists the loggers and their levels after
  applying the <em>sample4.xml</em> configuration file.
  </p>

  <table class="bodyTable">
    <tr>
      <th>Logger name</th>
      <th>Assigned Level</th>
      <th>Effective Level</th>
    </tr>
    <tr>
      <td>root</td>
      <td><code>OFF</code></td>
      <td><code>OFF</code></td>
    </tr>
    <tr class="alt">
      <td>chapter3</td>
      <td><code>INFO</code></td>
      <td><code>INFO</code></td>
    </tr>
    <tr>
      <td>chapter3.MyApp3</td>
      <td><code>null</code></td>
      <td><code>INFO</code></td>
    </tr>
    <tr class="alt">
      <td>chapter3.Foo</td>
      <td><code>null</code></td>
      <td><code>INFO</code></td>
    </tr>
  </table>

  <p>The ConsoleAppender named <em>STDOUT</em>, the only configured
  appender in <em>sample4.xml</em>, is attached to the root logger
  whose level is set to <code>OFF</code>. However, running
  <em>MyApp3</em> with configuration script <em>sample4.xml</em> will
  yield:
  </p>

  <div class="source"><pre>17:52:23.609 [main] INFO chapter3.MyApp3 - Entering application.
17:52:23.609 [main] INFO chapter3.MyApp3 - Exiting application.</pre></div>

  <p>Thus, the level of the root logger has no apparent effect because
  the loggers in <code>chapter3.MyApp3</code> and
  <code>chapter3.Foo</code> classes are all enabled for the
  <code>INFO</code> level.  As a side note, the <em>chapter3</em>
  logger exists by virtue of its declaration in the configuration file
  - even if the Java source code does not directly refer to it.
  </p>

  <h4>Configuring Appenders</h4>

  <p>Appenders are configured using <code>&lt;appender></code>
  elements, taking two attributes <span class="attr">name</span> and
  <span class="attr">class</span>, both of which are mandatory.  The
  <span class="attr">name</span> attribute specifies the name of the
  appender whereas the <span class="attr">class</span> attribute
  specifies the fully qualified name of the class of which the named
  appender will be an instance.  The <code>&lt;appender></code>
  element may contain zero or one <code>&lt;layout></code> elements
  and zero or more <code>&lt;filter></code> elements. Appart from
  these two common elements, <code>&lt;appender></code> elements may
  contain any number of element corresponding to javabean properties
  of the appender class. Seamlessly supporting any property of a given
  logback component is one of the major strengths of Joran. The
  following diagram illustrates the common structure. Note that
  support for properties is not visible.
  </p>

  <p align="left">
    <img src="images/chapter3/appenderSyntax.png" 
         alt="Appender Syntax" title="Appender element syntax"/>
  </p>

  <p>The <code>&lt;layout></code> element takes a mandatory class
  attribute specifying the fully qualified name of the class of which
  the associated layout should be an instance. Like the
  <code>&lt;appender></code> element, it may contain other elements
  corresponding to properties of the layout class.
  </p>

  <p>Logging to multiple appenders is as easy as defining the various
  appenders and referencing them in a logger, as the next
  configuration file illustrates:
  </p>

<em>Example 3.<span class="autoEx"/>: Multiple loggers (logback-examples/src/main/java/chapter3/multiple.xml)</em>
<pre class="prettyprint source">&lt;configuration>

  &lt;appender name="<b>FILE</b>" class="ch.qos.logback.core.FileAppender">
    &lt;file>myApp.log&lt;/file>

    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;appender name="<b>STDOUT</b>"
    class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="debug">
    <b>&lt;appender-ref ref="FILE" />
    &lt;appender-ref ref="STDOUT" /></b>
  &lt;/root>
&lt;/configuration></pre>

  <p>This configuration scripts defines two appenders called
  <em>FILE</em> and <em>STDOUT</em>.  The <em>FILE</em> appender logs
  to a file called <em>myApp.log</em>. The layout for this appender is
  a <code>PatternLayout</code> that outputs the date, level, thread
  name, logger name, file name and line number where the log request
  is located, the message and line separator character(s).  The second
  appender called <code>STDOUT</code> outputs to the console.  The
  layout for this appender outputs only the message string followed by
  a line separator.
  </p>

  <p>The appenders are attached to the root logger by referencing them
  by name within an <em>appender-ref</em> element. Note that each
  appender has its own layout. Layouts are usually not designed to be
  shared by multiple appenders. As such, logback configuration files
  do not provide any syntactical means for sharing layouts.
  </p>

  <p>By default, <b>appenders are cumulative</b>: a logger will log to
  the appenders attached to itself (if any) as well as all the
  appenders attached to its ancestors.  Thus, attaching the same
  appender to multiple loggers will cause logging output to be
  duplicated.
  </p>

  <em>Example 3.<span class="autoEx"/>: Duplicate appender
  (logback-examples/src/main/java/chapter3/duplicate.xml)</em>
<pre class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;logger name="chapter3">
    &lt;appender-ref ref="STDOUT" />
  &lt;/logger>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>Running <code>MyApp3</code> with <em>duplicate.xml</em> will
  yield the following output:
  </p>

<p class="source">14:25:36.343 [main] INFO  chapter3.MyApp3 - Entering application.
14:25:36.343 [main] INFO  chapter3.MyApp3 - Entering application.
14:25:36.359 [main] DEBUG chapter3.Foo - Did it again!
14:25:36.359 [main] DEBUG chapter3.Foo - Did it again!
14:25:36.359 [main] INFO  chapter3.MyApp3 - Exiting application.
14:25:36.359 [main] INFO  chapter3.MyApp3 - Exiting application.</p>

  <p>Notice the duplicated output. The appender named <em>STDOUT</em>
  is attached to two loggers, to root and to <em>chapter3</em>. Since
  the root logger is the ancestor of all loggers and <em>chapter3</em>
  is the parent of <em>chapter3.MyApp3</em> and <em>chapter3.Foo</em>,
  logging request made with these two loggers will be output twice,
  once because <em>STDOUT</em> is attached to <em>chapter3</em> and
  once because it is attached to <em>root</em>.
  </p>

  <p>Appender additivity is not intended as a trap for new users.  It
  is a quite convenient logback feature. For instance, you can
  configure logging such that log messages appear on the console (for
  all loggers in the system) while messages only from some specific
  set of loggers flow into a specific appender.
  </p>

  <em>Example 3.<span class="autoEx"/>: Multiple appender
  (logback-examples/src/main/java/chapter3/restricted.xml)</em>
  <pre class="prettyprint source">&lt;configuration>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;file>myApp.log&lt;/file>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;logger name="chapter3">
    &lt;appender-ref ref="FILE" />
  &lt;/logger>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>In this example, the console appender will log all the messages
  (for all loggers in the system) whereas only logging request
  originating from loggers <em>chapter3</em> and below go into the
  <em>myApp.log</em> file.
  </p>
	
  <h4>Overriding the default cumulative behaviour</h4>

  <p>In case the default cumulative behavior turns out to be
  unsuitable for your needs, you can override it by setting the
  additivity flag to false.  Thus, a branch in your logger tree may
  direct output to a set of appenders different than those of the rest
  of the tree.
  </p>

<em>Example 3.<span class="autoEx"/>: Additivity flag (logback-examples/src/main/java/chapter3/additivityFlag.xml)</em>
<pre class="prettyprint source">&lt;configuration>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;file>foo.log&lt;/file>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%date %level [%thread] %logger{10} [%file : %line] %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;logger name="chapter3.Foo" <b>additivity="false"</b>>
    &lt;appender-ref ref="FILE" />
  &lt;/logger>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>This example, the appender named <em>FILE</em> is attached to the
  <em>chapter3.Foo</em> logger. Moreover, the <em>chapter3.Foo</em>
  logger has its additivity flag set to false such that its logging
  output will be sent to the appender named <em>FILE</em> but not to
  any appender attached higher in the hierarchy. Other loggers remain
  oblivious to the additivity setting of the <em>chapter3.Foo</em>
  logger.  Running the <code>MyApp3</code> application with the
  <em>additivityFlag.xml</em> configuration file will output results
  on the console from the <em>chapter3.MyApp3</em> logger.  However,
  output from the <em>chapter3.Foo</em> logger will appear in the
  <em>foo.log</em> file and only in that file.
  </p>

  <h4><a name="variableSubstitution"
  href="#variableSubstitution">Variable substitution</a></h4>

  <p>In principle, variable substitution can occur at any point where
  a value can be specified. The syntax of variable substitution is
  similar to that of Unix shells. The string between an opening
  <em>${</em> and closing <em>}</em> is interpreted as a key.  The
  value of the substituted variable can be defined in the
  configuration file itself, in an external properties file or as a
  system property.  The corresponding value replaces <em>${aKey}</em>
  sequence. For example, if <em>java.home.dir</em> system property is
  set to <em>/home/xyz</em>, then every occurrence of the sequence
  <em>${java.home.dir}</em> will be interpreted as <em>/home/xyz</em>.
  </p>

  <h4>properties are inserted into the logger context</h4>

  <p>Note that the values defined via <code>&lt;property></code>
  element are actually inserted into the logger context. In other
  words, they become properties of the logger context.  Consequently,
  they will be available in all logging events as well as remotely
  after serialization.</p>

  <p>The next example shows a variable, a.k.a. a substitution
  property, declared the beginning of the configuration file. It is
  then used further down the file to specify the location of the
  output file.
  </p>

  <em>Example 3.<span class="autoEx"/>: Simple Variable substitution
  (logback-examples/src/main/java/chapter3/variableSubstitution1.xml)
  </em>

  <pre class="prettyprint source">&lt;configuration>

  <b>&lt;property name="USER_HOME" value="/home/sebastien" /></b>

  &lt;appender name="FILE"
    class="ch.qos.logback.core.FileAppender">
    <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>


  <p>The next example shows the use of a System property to achieve
  the same result. The property is not declared in the configuration
  file, thus logback will look for it in the System properties. Java
  system properties can be set on the command line.
  </p>
  
  <p class="source">java -DUSER_HOME="/home/sebastien" MyApp2</p>

  <em>Example 3.<span class="autoEx"/>: System Variable substitution
  (logback-examples/src/main/java/chapter3/variableSubstitution2.xml)
  </em>
  
  <pre class="prettyprint source">&lt;configuration>

  &lt;appender name="FILE"
    class="ch.qos.logback.core.FileAppender">
    <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

  
  <p>When multiple variables are needed, it may be more convenient to
  create a separate file that will contain all the variables. Here is
  how one can do such a setup.
  </p>

  <em>Example 3.<span class="autoEx"/>: Variable substitution using a
  separate file
  (logback-examples/src/main/java/chapter3/variableSubstitution3.xml)
  </em>

  <pre class="prettyprint source">&lt;configuration>

  <b>&lt;property file="src/main/java/chapter3/variables1.properties" /></b>

  &lt;appender name="FILE"
     class="ch.qos.logback.core.FileAppender">
     <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
     &lt;layout class="ch.qos.logback.classic.PatternLayout">
       &lt;Pattern>%msg%n&lt;/Pattern>
     &lt;/layout>
   &lt;/appender>

   &lt;root level="debug">
     &lt;appender-ref ref="FILE" />
   &lt;/root>
&lt;/configuration></pre>

   <p>This configuration file contains a reference to a file named
   <em>variables1.properties</em>.  The variables contained in that
   file will be read defined within the context of the logback
   configuration file. Here is what the <em>variable.properties</em>
   file might look like.
   </p>

   <em>Example 3.<span class="autoEx"/>: Variable file
   (logback-examples/src/main/java/chapter3/variables1.properties)</em>

   <pre class="source">USER_HOME=/home/sebastien</pre>

   <p>You may also reference a resource on the class path instead of a
   file.</p>

  <pre class="prettyprint source">&lt;configuration>

  <b>&lt;property resource="resource1.properties" /></b>

  &lt;appender name="FILE"
     class="ch.qos.logback.core.FileAppender">
     <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
     &lt;layout class="ch.qos.logback.classic.PatternLayout">
       &lt;Pattern>%msg%n&lt;/Pattern>
     &lt;/layout>
   &lt;/appender>

   &lt;root level="debug">
     &lt;appender-ref ref="FILE" />
   &lt;/root>
&lt;/configuration></pre>

   <h4>Nested variable substitution</h4>

   <p>Nested variabled subsitution is also supported. By nested, we
   mean that the value definition of a variable contains references to
   other variables. Suppose you wish to use variables to specify not
   only the destination directory but also the file name, and combine
   those two variables in a third variable called "destination". The
   properties file shown below gives an example.
   </p>


   <em>Example 3.<span class="autoEx"/>: Nested variable references
   (logback-examples/src/main/java/chapter3/variables2.properties)</em>

   <pre class="source">USER_HOME=/home/sebastien
fileName=myApp.log
<b>destination=${USER_HOME}/${fileName}</b></pre>

    <p>Note that in the properties file above, "destination" is
    composed out of two other variables, namely "USER_HOME" and
    "fileName".
    </p>
    
    <em>Example 3.<span class="autoEx"/>: Variable substitution using
    a separate file
    (logback-examples/src/main/java/chapter3/variableSubstitution4.xml)</em>

    <pre class="prettyprint source">&lt;configuration>

  &lt;property file="variables2.properties" />

  &lt;appender name="FILE"
    class="ch.qos.logback.core.FileAppender">
    <b>&lt;file>${destination}&lt;/file></b>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

  <h4><a name="defaultValuesForVariables"
  href="#defaultValuesForVariables">Default substitution values for
  variables</a></h4>

  <p>Under certain circumstances, it may be desirable for a variable
  to have a default value in case it is not declared or its value is
  null. As in the <a
  href="http://tldp.org/LDP/abs/html/parameter-substitution.html">Bash
  shell</a>, default values can be specified using the <b>":-"</b>
  operator. For example, assuming <em>aKey</em> is not defined,
  <code>"${aKey<b>:-golden</b>}"</code> will be interpreted as
  "golden".</p>
  

 
  <h3><a name="fileInclusion" href="#fileInclusion">File
  inclusion</a></h3>

  <p>Joran supports including parts of a configuration file from
  another file. This is done by declaring a <code>&lt;include></code>
  element, as shown below:
  </p>

  <em>Example 3.<span class="autoEx"/>: File include
  (logback-examples/src/main/java/chapter3/containingConfig.xml)</em>

  <pre class="prettyprint source">&lt;configuration>
  <b>&lt;include file="src/main/java/chapter3/includedConfig.xml"/></b>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="includedConsole" />
  &lt;/root>

&lt;/configuration></pre>

  <p>The target file MUST have its elements nested inside an
  <code>&lt;included></code> element. For example, a
  <code>ConsoleAppender</code> could be declared as:
  </p>

  <em>Example 3.<span class="autoEx"/>: File include
  (logback-examples/src/main/java/chapter3/includedConfig.xml)</em>

  <pre class="source"><b class="green big">&lt;included></b>
  &lt;appender name="includedConsole" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>"%d - %m%n"&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>
<b class="green big">&lt;/included></b></pre>

  <p>The file to be included can be referenced as a file, as a URL or
  as a resource. To reference a file use the <span
  class="attr">file</span> attribute. To reference a URL use the <span
  class="attr">url</span> attribute. To reference a resource, use the
  <span class="attr">resource</span> attribute.
  </p>


  <h3><a name="contextName" href="#contextName">Setting the context name</a></h3>

  <p>As mentioned <a href="architecture.html#LoggerContext">in an
  earlier chapter</a>, every logger is attached to logger context. By
  default, the logger context is called "default". However, you can
  set a different name with the help of the
  <code>&lt;contextName></code> configuration directive. Note that
  once set, the logger context name <a
  href="../apidocs/ch/qos/logback/core/ContextBase.html#setName(java.lang.String)">cannot
  be changed</a>. Setting the context name is a simple and
  straightforward method in order to distinguish between multiple
  applications logging to the same target.
  </p>
  
  <em>Example 3.<span class="autoEx"/>: Set the context name and display it
  (logback-examples/src/main/java/chapter3/contextName.xml)</em>
  <pre class="prettyprint source">&lt;configuration>
  <b>&lt;contextName>myAppName&lt;/contextName></b>
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%d <b>%contextName</b> [%t] %level %logger{36} - %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>This last examples illustrates naming of the logger
  context. Adding the the <a
  href="layouts.html#conversionWord">contextName conversion word</a>
  in layout's pattern will output the said name.</p>

   <h3><a name="insertFromJNDI" href="#insertFromJNDI">Obtaining
   variables from JNDI</a></h3>

   <p>Under certain circumstances, you may want to make use of
   env-entries stored in JNDI. The <code>&lt;insertFromJNDI></code>
   configuration directive extracts an env-entry stored in JNDI and
   inserts it as variable as specified by the <span
   class="attr">as</span> attribute.
   </p>

   <em>Example 3.<span class="autoEx"/>: Insert as properties env-entries obtained via JNDI
  (logback-examples/src/main/java/chapter3/insertFromJNDI.xml)</em>
   <pre class="prettyprint source">&lt;configuration>
  <b>&lt;insertFromJNDI env-entry-name="java:comp/env/appName" as="<span class="green">appName"</span> /></b>
  <b>&lt;contextName><span class="green">${appName}</span>&lt;/contextName></b>

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%d %contextName %level %msg %logger{50}%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>
&lt;/configuration></pre>

  <p>In this last example, the "java:comp/env/appName" env-entry is
  inserted as the <span class="variable">appName</span> property. Note
  that the <code>&lt;contextName></code> directive sets the context
  name based on the value of the <span class="variable">appName</span>
  property inserted by the previous <code>&lt;insertFromJNDI></code>
  directive..

</p>

  <script src="../templates/footer.js" type="text/javascript"></script>
</div>
</body>
</html>
