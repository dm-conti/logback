<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <title>Chapter 8: Context Selector</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen" />
  </head>
  <body onload="prettyPrint()">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <div id="left">
      <noscript>Please turn on Javascript to view this menu</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">	
	
    <h2>Chapter 9: Context Selectors</h2>
      
    <div class="quote">
      <p><em>It is not knowledge, but the act of learning, not
      possession but the act of getting there, which grants the greatest
      enjoyment. When I have clarified and exhausted a subject, then I
      turn away from it, in order to go into darkness again; the
      never-satisfied man is so strange if he has completed a structure,
      then it is not in order to dwell in it peacefully, but in order to
      begin another. I imagine the world conqueror must feel thus, who,
      after one kingdom is scarcely conquered, stretches out his arms
      for others.</em></p>

      <p>&mdash;KARL FRIEDRICH GAUSS, Letter to Bolyai, 1808.</p>

      <p><em>Style, like sheer silk, too often hides eczema.</em></p>
      
      <p>&mdash;ALBERT CAMUS, <em>The Fall</em></p>

    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>		
    <script src="../templates/setup.js" type="text/javascript"></script>

    <h2>The problem: Logging Separation</h2>

    <p>The chapter deals with a relatively difficult problem of
    providing a separate logging environment for multiple applications
    running on the same web or EJB container. In the remainder of this
    chapter the term "application" will be used to refer either a
    web-application or a J2EE application interchangeably.  In a
    separated logging environment, each application sees a distinct
    logback environment, so that the logback configuration of one
    application does not interfere with the settings of another. In
    more technical terms, each web-application has a distinct copy of
    <code>LoggerContext</code> reserved for its own use. Recall that
    in logback, each logger object is manufactured by a
    <code>LoggerContext</code> to which it remains attached for as
    long as the logger object lives in memory. A variant of this
    problem is the separation of application logging and the logging
    of the container itself.
    </p>

    <h2>The simplest and easiest approach</h2>

    <p>Assuming your container supports child first class loading,
    separation of logging can be accomplished by embedding a copy of
    slf4j and logback jar files in each of your applications. For
    web-applications, placing slf4j and logback jar files under the
    <em>WEB-INF/lib</em> directory of the web-application is
    sufficient to endow each web-application with a separate logging
    environment. A copy of the <em>logback.xml</em> configuration file
    placed under <em>WEB-INF/classes</em> will be picked up when
    logback is loaded into memory. 
    </p>

    <p>By virtue of class loader separation provided by the container,
    each web-application will load its own copy of
    <code>LoggerContext</code> which will pickup its own copy of
    <em>logback.xml</em>.</p>
    
    <p>Easy as pie.</p>

    <p>Well, not exactly. First, although most do, not all containers
    support child first class loading. Second, logging generated by
    shared libraries will not be separated. The common idiom for
    referencing a logger is via a static reference. For example,
    </p>

    <pre class="prettyprint source">public class Foo {
  <b>static</b> Logger logger = LoggerFactory.getLogger(Foo.class);
  ...
}</pre>

    <p>Static references are both memory and CPU efficient. Only one
    logger reference is used for all instances of the class. Moreover,
    the logger instance is retrieved only once, when the class is
    loaded into memory. Static logger references are fine as long as
    they are used in classes loaded by different class
    loaders. However, when a class is loaded by a parent class loader
    common to multiple applications, then the shared class in question
    will be loaded once and for all applications. If the shared class
    contains a static logger reference, than the logger will be
    retrieved once, when the shared class is loaded into memory and
    initialized. Moreover, for the shared class to successfully load
    into memory, slf4j and logback classed must be resolvable by the
    parent class loader.  This implies that slf4j and logback jar
    files must also be accessible to the parent class loader. Note
    that for this scenario to occur a class must be shared
    <em>and</em> use slf4j, which is somewhat uncommon.
    </p>

    <p>However, if the container itself uses SLF4J and defaults to
    parent-first class loading, then you need context selectors. Read
    on.
    </p>

    <h2>Context Selectors</h2>


    <p>Logback provides a mechanism for a single instance of SLF4J and
    logback classes loaded into memory to provide multiple logger
    contexts. When you write:
    </p>

    <pre class="prettyprint source">Logger logger = LoggerFactory.getLogger("foo");</pre>

    <p>the <code>getLogger</code>() method in
    <code>LoggerFactory</code> class asks the SLF4J binding for a
    <code>ILoggerFactory</code>. When SLF4J is bound to logback, the
    task of returning an <code>ILoggerFactory</code> is delegated to
    an instance of <a
    href="../apidocs/ch/qos/logback/classic/selector/ContextSelector.html">ContextSelector</a>. Note
    that <code>ContextSelector</code> implementations always return
    instances of the <code>LoggerContext</code> class. This class
    implements the <code>ILoggerFactory</code> interface.  In other
    words, a context selector has the option to returning any
    <code>LoggerContext</code> instance it sees fit according to its
    own criteria. Hence the name context <em>selector</em>.
    </p>

    <p>By default, the logback binding uses <a
    href="../xref/ch/qos/logback/classic/selector/DefaultContextSelector.html">DefaultContextSelector</a>
    which always returns the same <code>LoggerContext</code>, called
    the default logger context.</p>

    <p>You can specify a different context selector by setting the
    <em>logback.ContextSelector</em> system property. Suppose you
    would like to specify that context selector to an instance of the
    <code>myPackage.myContextSelector</code> class, you would add the
    following system property: </p>

    <p class="source">-Dlogback.ContextSelector=myPackage.myContextSelector</p>

    <p>The context selector needs to implement the
    <code>ContextSelector</code> interface and have a constructor
    method admitting a <code>LoggerContext</code> instance as its only
    parameter.
    </p>


    <h3>ContextJNDISelector</h3>

    <p>Logback-classic ships with a selector called
    <code>ContextJNDISelector</code> which selects the logger context
    based on data available in JNDI. This leverages JNDI data
    separation mandated by the J2EE specification. The same
    environment variable can be set to carry a different value in each
    application.
    </p>

    <p>To enable <code>ContextJNDISelector</code>, the
    <em>logback.ContextSelector</em> system property needs to be set
    to "JNDI", as follows:</p>

    <p class="source">-Dlogback.ContextSelector=JNDI</p>

    <p>Note that JNDI is a convenient shorthand for
    "ch.qos.logback.classic.selector.ContextJNDISelector".</p>

    <h3>Setting JNDI variables in applications</h3>
    
    <p>In each of your applications, you need to name the logging
    context for the application. For a web-application, JNDI
    environment entries are specified within the <em>web.xml</em>
    file. If "kenobi" was the name of your application, you would add
    the following XML element to kenobi's web.xml file:</p>

    <pre class="prettyprint source">&lt;env-entry>
  &lt;env-entry-name>logback/context-name&lt;/env-entry-name>
  &lt;env-entry-type>java.lang.String&lt;/env-entry-type>
  &lt;env-entry-value>kenobi&lt;/env-entry-value>
&lt;/env-entry></pre>

    <p>Assuming you have enabled <code>ContextJNDISelector</code>,
    logging for Kenobi will be done using a logger context named
    "kenobi". Moreover, the "kenobi" logger context will be
    initialized by <em>convention</em> using the configuration file
    called <em>logback-kenobi.xml</em> which should be packaged within
    Kenobi web-application under the <em>WEB-INF/classes</em> folder.
    </p>

    <p>Although not required, you may specify a different
    configuration file other than the convention, by setting the
    "logback/configuration-resource" JNDI variable. For example, if
    you wish to specify <em>my_config.xml</em> instead of the
    conventional <em>logback-kenobi.xml</em>, you would add the
    following XML element to web.xml
    </p>


   <pre class="prettyprint source">&lt;env-entry>
  &lt;env-entry-name>logback/configuration-resource&lt;/env-entry-name>
  &lt;env-entry-type>java.lang.String&lt;/env-entry-type>
  &lt;env-entry-value>my_config.xml&lt;/env-entry-value>
&lt;/env-entry></pre> 


    <h3>Configuring Tomcat for ContextJNDISelector</h3>

    <p>First, place the logback jars (that is
    logback-classic-${project.version}.jar,
    logback-core-${project.version}.jar and
    slf4j-api-${slff4j.version}.jar) in Tomcat's global (shared) class
    folder. In Tomcat 6.x, this directory is
    <em>$TOMCAT_HOME/lib/</em>.
    </p>

    <p>The <em>logback.ContextSelector</em> system property can be set
    by adding the following line to the <em>catalina.sh</em> script,
    catalina.bat in Windows, found under <em>$TOMCAT_HOME/bin</em>
    folder.</p>

    <p class="source">JAVA_OPTS="$JAVA_OPTS -Dlogback.ContextSelector=JNDI"</p>


    <h3>Hot deploying applications</h3>


    <p>When the web-application is recycled or shutdown, we strongly
    recommend that the older <code>LoggerContext</code> be closed and
    subsequently discarded. Logback ships with a
    <code>ServletContextListener</code> called
    <code>ContextDetachingSCL</code>, designed specifically for
    detaching the <code>ContextSelector</code> instance associated
    with the older web-application instance. In order to install it,
    add the following lines to your web-applications <em>web.xml</em>
    file.</p>

    <pre class="prettyprint source">&lt;listener>
  &lt;listener-class>ch.qos.logback.classic.selector.servlet.ContextDetachingSCL&lt;/listener-class>
&lt;/listener></pre>

    <h3>Better performance</h3>

    <p>When <code>ContextJNDISelector</code> is active, each time a
    logger is retrieved, a JNDI lookup must be performed. This can
    negatively impact performance, especially if you are using
    non-static (aka instance) logger references. Logback ships with a
    servlet filter named <a
    href="../xref/ch/qos/logback/classic/selector/servlet/LoggerContextFilter.html">LoggerContextFilter</a>,
    specifically designed to circumvent the JNDI lookup cost. It can
    be installed by adding the following lines to your applications
    web.xml file.</p>

 <pre class="prettyprint source">&lt;filter>
  &lt;filter-name>LoggerContextFilter&lt;/filter-name>
  &lt;filter-class>ch.qos.logback.classic.selector.servlet.LoggerContextFilter&lt;/filter-class>
&lt;/filter>
&lt;filter-mapping>
  &lt;filter-name>LoggerContextFilter&lt;/filter-name>
  &lt;url-pattern>/*&lt;/url-pattern>
&lt;/filter-mapping></pre>

   <p>At the beginning of each http-request,
   <code>LoggerContextFilter</code> will obtain the logger context
   associated with the application and then place it in a
   <code>ThreadLocal</code> variable. <code>ContextJNDISelector</code>
   will first check if the said <code>ThreadLocal</code> variable is
   set. If it is set, then JNDI lookup will skipped. Note that at the
   end of the http request, the <code>ThreadLocal</code> variable will
   be nulled.  Installing <code>LoggerContextFilter</code> improves
   logger retrieval performance by a wide margin.
   </p>

   <p>Nulling the <code>ThreadLocal</code> variable allows garbage
   collection of the web-application when it is stopped or
   recycled.</p>

  <script src="../templates/footer.js" type="text/javascript"></script>
</div>
</body>
</html>
